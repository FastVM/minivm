
#include <stdio.h>
#include <stdlib.h>
#include "../../dynasm/dasm_proto.h"
#include "../../dynasm/dasm_x86.h"
#if _WIN32
#include <Windows.h>
#else
#include <sys/mman.h>
#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
#define MAP_ANONYMOUS MAP_ANON
#endif
#endif

#include "../ir.h"
#include "../type.h"

#define VM_NREGS 256

typedef void func(void);

typedef struct {
    int x;
} vm_state_t;

|.arch x64

#define rArg0 7
#define rArg1 6
#define rArg2 2
#define rArg3 1
#define rArg4 8
#define rArg5 9
// its my abi, mom!
#define rArg6 10
#define rArg7 11
#define rArg8 12

|.define RAX, 0
|.define RCX, 1
|.define RDX, 2
|.define RBX, 3
|.define RSP, 4
|.define RBP, 5
|.define RSI, 6
|.define RDI, 7
|.define R8, 8
|.define R9, 9
|.define R10, 10
|.define R11, 11
|.define R12, 12
|.define R13, 13
|.define R14, 14
|.define R15, 15

|.macro pusha
| push rax
| push rcx
| push rdx
| push rbx
| push rbp
| push rsi
| push rdi
| push r8
| push r9
| push r10
| push r11
| push r12
| push r13
| push r14
| push r15
|.endmacro
|.macro popa
| pop r15
| pop r14
| pop r13
| pop r12
| pop r11
| pop r10
| pop r9
| pop r8
| pop rdi
| pop rsi
| pop rbp
| pop rbx
| pop rdx
| pop rcx
| pop rax
|.endmacro

|.macro vmload8, arg1, arg2
|| {
    || vm_arg_t arg = arg2;
    || if (arg.type == VM_ARG_REG) {
        | mov Rb(arg1), [rsp + (8 * arg.reg + 8)]
    || } else if (arg.type == VM_ARG_NUM) {
        || int8_t n = (int8_t) arg.num;
        | mov Rb(arg1), n
    ||}
|| }
|.endmacro

|.macro vmload16, arg1, arg2
|| {
    || vm_arg_t arg = arg2;
    || if (arg.type == VM_ARG_REG) {
        | mov Rw(arg1), [rsp + (8 * arg.reg + 8)]
    || } else if (arg.type == VM_ARG_NUM) {
        || int16_t n = (int16_t) arg.num;
        | mov Rw(arg1), n
    ||}
|| }
|.endmacro

|.macro vmload32, arg1, arg2
|| {
    || vm_arg_t arg = arg2;
    || if (arg.type == VM_ARG_REG) {
        | mov Rq(arg1), [rsp + (8 * arg.reg + 8)]
    || } else if (arg.type == VM_ARG_NUM) {
        || int32_t n = (int32_t) arg.num;
        | mov Rd(arg1), n
    ||}
|| }
|.endmacro

|.macro vmload64, arg1, arg2
|| {
    || vm_arg_t arg = arg2;
    || if (arg.type == VM_ARG_REG) {
        | mov Rq(arg1), [rsp + (8 * arg.reg + 8)]
    || } else if (arg.type == VM_ARG_NUM) {
        || int64_t n = (int64_t) arg.num;
        || int32_t t = (int32_t) n;
        || if (n == (int64_t) t) {
            | mov Rd(arg1), n
        || } else {
            | mov64 Rq(arg1), n
        || }
    ||}
|| }
|.endmacro

|.macro vmstore8, arg1, arg2
|| {
    || vm_arg_t arg = arg1;
    || if (arg.type == VM_ARG_REG) {
        | mov [rsp + (8 * arg.reg + 8)], Rb(arg2)
    || }
|| }
|.endmacro

|.macro vmstore16, arg1, arg2
|| {
    || vm_arg_t arg = arg1;
    || if (arg.type == VM_ARG_REG) {
        | mov [rsp + (8 * arg.reg + 8)], Rw(arg2)
    || }
|| }
|.endmacro

|.macro vmstore32, arg1, arg2
|| {
    || vm_arg_t arg = arg1;
    || if (arg.type == VM_ARG_REG) {
        | mov [rsp + (8 * arg.reg + 8)], Rd(arg2)
    || }
|| }
|.endmacro

|.macro vmstore64, arg1, arg2
|| {
    || vm_arg_t arg = arg1;
    || if (arg.type == VM_ARG_REG) {
        | mov [rsp + (8 * arg.reg + 8)], Rq(arg2)
    || }
|| }
|.endmacro

|.macro vmjump, arg1
|| {
    ||vm_rblock_t *block = arg1;
    ||bool last_mark = block->is_marked;
    ||block->is_marked = true;
    ||block->is_func = false;
    ||void **bit = vm_malloc(sizeof(void *));
    ||*bit = NULL;
    | mov64 rbx, ((uint64_t)bit)
    | mov rax, [rbx]
    | test rax, rax
    | jnz >9
    | mov64 rax, ((uint64_t) &vm_jit_rblock)
    | mov64 Rq(rArg0), ((uint64_t) state) 
    | mov64 Rq(rArg1), ((uint64_t) block)
    | call rax
    | mov64 rbx, ((uint64_t)bit)
    | mov [rbx], rax
    |9:
    | jmp rax
    || block->is_marked = last_mark;
|| }
|.endmacro

static size_t vm_jit_putchar(size_t c) {
    fprintf(stdout, "%c", (char) c);
    return 0;
}

static void* vm_jit_encode(dasm_State** d)
{
    size_t sz;
    void* buf;
    dasm_link(d, &sz);
#ifdef _WIN32
    buf = VirtualAlloc(0, sz, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
#else
    buf = mmap(0, sz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
#endif
    dasm_encode(d, buf);
#ifdef _WIN32
    DWORD dwOld;
    VirtualProtect(buf, sz, PAGE_EXECUTE_READ, &dwOld);
#else
    mprotect(buf, sz, PROT_READ | PROT_EXEC);
#endif
    // char chrs[256];
    // sprintf(chrs, "%p.bin", buf);
    // FILE *f = fopen(chrs, "wb");
    // fwrite(buf, sz, 1, f);
    // fclose(f);
    return buf;
}

#define Dst (&d)

void *vm_jit_rblock(vm_state_t *state, vm_rblock_t *rblock) {
    bool first = state->x++ == 0;
    static uint8_t ccregs[] = { rArg0, rArg1, rArg2, rArg3, rArg4, rArg5, rArg6, rArg7, rArg8 };
    void *cached = vm_cache_get(&rblock->block->cache, rblock);
    if (cached != NULL) {
        return cached;
    }
    dasm_State* d;
    |.section code
    dasm_init(&d, DASM_MAXSECTION);
    |.globals lbl_
    void* labels[lbl__MAX];
    dasm_setupglobal(&d, labels, lbl__MAX);
    |.actionlist act
    dasm_setup(&d, act);
    dasm_growpc(&d, 8);
    |.code
    |->main:
    if (rblock->is_func) {
        | sub rsp, (8 * VM_NREGS)
        for (size_t i = 1; i <= rblock->block->nargs; i++) {
            | mov [rsp + (8 * i + 8)], Rq(ccregs[i-1])
        }
    }
    vm_block_t *block = rblock->block;
    vm_tag_t *types = vm_rblock_regs_dup(rblock->regs);
    vm_rblock_t *rnext = vm_rblock_new(rblock->block, rblock->regs);
    rnext->start = rblock->start;
    rnext->is_func = rblock->is_func;
    // vm_print_block(stdout, rblock->block);
    for (size_t ninstr = rnext->start; ninstr < block->len; ninstr++) {
        vm_instr_t instr = vm_rblock_type_specialize_instr(types, block->instrs[ninstr]);
        if (!vm_rblock_type_check_instr(types, instr)) goto fail_return;
        // vm_print_instr(stdout, instr); fprintf(stdout, "\n"); 
        switch (instr.op) {
        case VM_IOP_NOP: {
            break;
        }
        case VM_IOP_MOVE: {
            | vmload64 RAX, instr.args[0]
            | vmstore64 instr.out, RAX
            break;
        }
        case VM_IOP_CAST: {
            break;
        }
        case VM_IOP_ADD: {
            switch (instr.tag) {
            case VM_TAG_I8:
            case VM_TAG_U8:{
                | vmload8 RAX, instr.args[0]
                | vmload8 RCX, instr.args[1]
                | add al, cl
                | vmstore8 instr.out, RAX
                break;
            }
            case VM_TAG_I16:
            case VM_TAG_U16:{
                | vmload16 RAX, instr.args[0]
                | vmload16 RCX, instr.args[1]
                | add ax, cx
                | vmstore16 instr.out, RAX
                break;
            }
            case VM_TAG_I32:
            case VM_TAG_U32: {
                | vmload32 RAX, instr.args[0]
                | vmload32 RCX, instr.args[1]
                | add eax, ecx
                | vmstore32 instr.out, RAX
                break;
            }
            case VM_TAG_I64:
            case VM_TAG_U64: {
                | vmload64 RAX, instr.args[0]
                | vmload64 RCX, instr.args[1]
                | add rax, rcx
                | vmstore64 instr.out, RAX
                break;
            }
            }
            break;
        }
        case VM_IOP_SUB: {
            switch (instr.tag) {
            case VM_TAG_I8:
            case VM_TAG_U8:{
                | vmload8 RAX, instr.args[0]
                | vmload8 RCX, instr.args[1]
                | sub al, cl
                | vmstore8 instr.out, RAX
                break;
            }
            case VM_TAG_I16:
            case VM_TAG_U16:{
                | vmload16 RAX, instr.args[0]
                | vmload16 RCX, instr.args[1]
                | sub ax, cx
                | vmstore16 instr.out, RAX
                break;
            }
            case VM_TAG_I32:
            case VM_TAG_U32: {
                | vmload32 RAX, instr.args[0]
                | vmload32 RCX, instr.args[1]
                | sub eax, ecx
                | vmstore32 instr.out, RAX
                break;
            }
            case VM_TAG_I64:
            case VM_TAG_U64: {
                | vmload64 RAX, instr.args[0]
                | vmload64 RCX, instr.args[1]
                | sub rax, rcx
                | vmstore64 instr.out, RAX
                break;
            }
            }
            break;
        }
        case VM_IOP_MUL: {
            switch (instr.tag) {
            case VM_TAG_I8:
            case VM_TAG_U8: {
                | xor ax, ax
                | vmload8 RAX, instr.args[0]
                | vmload8 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I8) {
                    | imul cl
                } else {
                    | mul cl
                }
                | vmstore8 instr.out, RAX
                break;
            }
            case VM_TAG_I16:
            case VM_TAG_U16: {
                | vmload16 RAX, instr.args[0]
                | vmload16 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I16) {
                    | imul cx
                } else {
                    | mul cx
                }
                | vmstore16 instr.out, RAX
                break;
            }
            case VM_TAG_I32:
            case VM_TAG_U32: {
                | vmload32 RAX, instr.args[0]
                | vmload32 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I32) {
                    | imul ecx
                } else {
                    | mul ecx
                }
                | vmstore32 instr.out, RAX
                break;
            }
            case VM_TAG_I64:
            case VM_TAG_U64: {
                | vmload64 RAX, instr.args[0]
                | vmload64 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I64) {
                    | imul rcx
                } else {
                    | mul rcx
                }
                | vmstore64 instr.out, RAX
                break;
            }
            }
            break;
        }
        case VM_IOP_DIV: {
            switch (instr.tag) {
            case VM_TAG_I8:
            case VM_TAG_U8: {
                | xor ax, ax
                | vmload8 RAX, instr.args[0]
                | vmload8 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I8) {
                    | idiv cl
                } else {
                    | div cl
                }
                | vmstore8 instr.out, RAX
                break;
            }
            case VM_TAG_I16:
            case VM_TAG_U16: {
                | xor dx, dx
                | vmload16 RAX, instr.args[0]
                | vmload16 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I16) {
                    | idiv cx
                } else {
                    | div cx
                }
                | vmstore16 instr.out, RAX
                break;
            }
            case VM_TAG_I32:
            case VM_TAG_U32: {
                | xor edx, edx
                | vmload32 RAX, instr.args[0]
                | vmload32 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I32) {
                    | idiv ecx
                } else {
                    | div ecx
                }
                | vmstore32 instr.out, RAX
                break;
            }
            case VM_TAG_I64:
            case VM_TAG_U64: {
                | xor edx, edx
                | vmload64 RAX, instr.args[0]
                | vmload64 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I64) {
                    | idiv rcx
                } else {
                    | div rcx
                }
                | vmstore64 instr.out, RAX
                break;
            }
            }
            break;
        }
        case VM_IOP_MOD: {
            switch (instr.tag) {
            case VM_TAG_I8:
            case VM_TAG_U8: {
                | xor ax, ax
                | vmload8 RAX, instr.args[0]
                | vmload8 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I8) {
                    | idiv cl
                } else {
                    | div cl
                }
                | mov dl, ah
                | vmstore8 instr.out, RDX
                break;
            }
            case VM_TAG_I16:
            case VM_TAG_U16: {
                | xor dx, dx
                | vmload16 RAX, instr.args[0]
                | vmload16 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I16) {
                    | idiv cx
                } else {
                    | div cx
                }
                | vmstore16 instr.out, RDX
                break;
            }
            case VM_TAG_I32:
            case VM_TAG_U32: {
                | xor edx, edx
                | vmload32 RAX, instr.args[0]
                | vmload32 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I32) {
                    | idiv ecx
                } else {
                    | div ecx
                }
                | vmstore32 instr.out, RDX
                break;
            }
            case VM_TAG_I64:
            case VM_TAG_U64: {
                | xor edx, edx
                | vmload64 RAX, instr.args[0]
                | vmload64 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I64) {
                    | idiv rcx
                } else {
                    | div rcx
                }
                | vmstore64 instr.out, RDX
                break;
            }
            }
            break;
        }
        case VM_IOP_CALL: {
            if (instr.args[0].type == VM_ARG_FUNC) {
                vm_tag_t *argtypes = vm_rblock_regs_empty();
                for (size_t i = 1; instr.args[i].type != VM_ARG_NONE; i++) {
                    argtypes[i] = types[instr.args[i].reg];
                }
                vm_rblock_t *func = vm_rblock_new(instr.args[0].func, argtypes);
                func->is_func = true;
                for (size_t i = 1; instr.args[i].type != VM_ARG_NONE; i++) {
                    | vmload64 ccregs[i-1], instr.args[i] 
                }
                void *code = vm_jit_rblock(state, func);
                | mov64 rax, ((uint64_t) code)
                | call rax
                | vmstore64 instr.out, RAX
            }
            break;
        }
        case VM_IOP_OUT: {
            | xor Rd(rArg0), Rd(rArg0)
            switch (instr.tag) {
            case VM_TAG_I8:
            case VM_TAG_U8: {
                | vmload8 rArg0, instr.args[0]
                break;
            }
            case VM_TAG_I16:
            case VM_TAG_U16: {
                | vmload16 rArg0, instr.args[0]
                break;
            }
            case VM_TAG_I32:
            case VM_TAG_U32: {
                | vmload32 rArg0, instr.args[0]
                break;
            }
            case VM_TAG_I64:
            case VM_TAG_U64: {
                | vmload64 rArg0, instr.args[0]
                break;
            }
            }
            | mov64 rax, ((uint64_t) &vm_jit_putchar)
            | call rax
            break;
        }
        case VM_IOP_IN: {
            printf("IN\n");
            break;
        }
        case VM_IOP_BNOT: {
            break;
        }
        case VM_IOP_BOR: {
            break;
        }
        case VM_IOP_BAND: {
            break;
        }
        case VM_IOP_BXOR: {
            break;
        }
        case VM_IOP_BSHL: {
            break;
        }
        case VM_IOP_BSHR: {
            break;
        }
        }
        if (instr.out.type == VM_ARG_REG) {
            types[instr.out.reg] = instr.tag;
        }
    }
    vm_branch_t branch = vm_rblock_type_specialize_branch(types, block->branch);
    if (!vm_rblock_type_check_branch(types, branch)) goto fail_return;
    switch (branch.op) {
    case VM_BOP_EXIT: {
        | xor Rd(rArg0), Rd(rArg0)
        | mov64 rax, ((uint64_t) &exit)
        | call rax
        break;
    }
    case VM_BOP_RET: {
        | vmload64 RAX, branch.args[0]
        | add rsp, (8 * VM_NREGS)
        | ret
        break;
    }
    case VM_BOP_JUMP: {
        | vmjump vm_rblock_new(branch.targets[0], types)
        break;
    }
    case VM_BOP_BB: {
        switch (branch.tag) {
        case VM_TAG_I8:
        case VM_TAG_U8: {
            | vmload8 RAX, branch.args[0]
            | test al, cl
            break;
        }
        case VM_TAG_I16:
        case VM_TAG_U16: {
            | vmload16 RAX, branch.args[0]
            | test ax, cx
            break;
        }
        case VM_TAG_I32:
        case VM_TAG_U32: {
            | vmload32 RAX, branch.args[0]
            | test eax, ecx
            break;
        }
        case VM_TAG_I64:
        case VM_TAG_U64: {
            | vmload64 RAX, branch.args[0]
            | test rax, rcx
            break;
        }
        }
        | jnz >1
        | vmjump vm_rblock_new(branch.targets[1], types)
        |1:
        | vmjump vm_rblock_new(branch.targets[0], types)
        break;
    }
    case VM_BOP_BEQ: {
        switch (branch.tag) {
        case VM_TAG_I8:
        case VM_TAG_U8: {
            | vmload8 RAX, branch.args[0]
            | vmload8 RCX, branch.args[1]
            | cmp al, cl
            break;
        }
        case VM_TAG_I16:
        case VM_TAG_U16: {
            | vmload16 RAX, branch.args[0]
            | vmload16 RCX, branch.args[1]
            | cmp ax, cx
            break;
        }
        case VM_TAG_I32:
        case VM_TAG_U32: {
            | vmload32 RAX, branch.args[0]
            | vmload32 RCX, branch.args[1]
            | cmp eax, ecx
            break;
        }
        case VM_TAG_I64:
        case VM_TAG_U64: {
            | vmload64 RAX, branch.args[0]
            | vmload64 RCX, branch.args[1]
            | cmp rax, rcx
            break;
        }
        }
        | je >1
        | vmjump vm_rblock_new(branch.targets[1], types)
        |1:
        | vmjump vm_rblock_new(branch.targets[0], types)
        break;
    }
    case VM_BOP_BLT: {
        switch (branch.tag) {
        case VM_TAG_I8:
        case VM_TAG_U8: {
            | vmload8 RAX, branch.args[0]
            | vmload8 RCX, branch.args[1]
            | cmp al, cl
            break;
        }
        case VM_TAG_I16:
        case VM_TAG_U16: {
            | vmload16 RAX, branch.args[0]
            | vmload16 RCX, branch.args[1]
            | cmp ax, cx
            break;
        }
        case VM_TAG_I32:
        case VM_TAG_U32: {
            | vmload32 RAX, branch.args[0]
            | vmload32 RCX, branch.args[1]
            | cmp eax, ecx
            break;
        }
        case VM_TAG_I64:
        case VM_TAG_U64: {
            | vmload64 RAX, branch.args[0]
            | vmload64 RCX, branch.args[1]
            | cmp rax, rcx
            break;
        }
        }
        switch (branch.tag) {
        case VM_TAG_I8:
        case VM_TAG_I16:
        case VM_TAG_I32:
        case VM_TAG_I64: {
            | jl >1
            break;
        }
        case VM_TAG_U8:
        case VM_TAG_U16:
        case VM_TAG_U32:
        case VM_TAG_U64: {
            | jb >1
            break;
        }
        }
        | vmjump vm_rblock_new(branch.targets[1], types)
        |1:
        | vmjump vm_rblock_new(branch.targets[0], types)
        break;
    }
    }
    vm_jit_encode(&d);
    // dasm_free(&d);   
    void *fn = labels[lbl_main];
    vm_cache_set(&rblock->block->cache, rnext, fn);
    return fn;
fail_return:;
    // fprintf(stderr, "FAIL\n");
    return NULL;
}

void vm_jit_run(vm_block_t *block) {
    vm_rblock_t *rblock = vm_rblock_new(block, vm_rblock_regs_empty());
    rblock->is_func = true;
    vm_state_t state = {0};
    void(*fn)(void) = vm_jit_rblock(&state, rblock);
    fn();
    exit(0);
}
