
#include <stdio.h>
#include <stdlib.h>
#include "../../dynasm/dasm_proto.h"
#include "../../dynasm/dasm_x86.h"

#if defined(VM_MINGW)
#include <windows.h>
#elif defined(_WIN32)
#include <Windows.h>
#else
#include <sys/mman.h>
#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
#define MAP_ANONYMOUS MAP_ANON
#endif
#endif
#define VM_NREGS 256

#include "jit.h"

static void vm_jit_rblock_single(vm_jit_state_t *state, dasm_State **dst, vm_rblock_t *rnext);
static void *vm_jit_rblock(vm_jit_state_t *state, vm_rblock_t *rblock, bool isfunc);

|.arch x64

#define RAX 0
#define RCX 1
#define RDX 2
#define RBX 3
#define RSP 4
#define RBP 5
#define RSI 6
#define RDI 7
#define R8 8
#define R9 9
#define R10 10
#define R11 11
#define R12 12
#define R13 13
#define R14 14
#define R15 15

#define rArg0 RDI
#define rArg1 RSI
#define rArg2 RDX
#define rArg3 RCX
#define rArg4 R8
#define rArg5 R9

|.macro mov32q64, rno, num
||{
    ||size_t reg = (rno);
    ||uint64_t v64 = (uint64_t) (num);
    ||uint64_t v32 = (uint32_t) (v64);
    ||if ((uint64_t) v32 == v64) {
        |mov Rd(reg), v32
    ||} else {
        |mov64 Rq(reg), v64
    ||}
||}
|.endmacro

|.macro invoke, func
|| {
    || void *ptr = (void*) (func);
    | mov32q64 RAX, ((uint64_t) (ptr))
    | call rax
|| }
|.endmacro

|.macro vmjump, arg1
|| {
    ||vm_rblock_t *block = arg1;
    ||block->isfunc = false;
    ||void *got = vm_cache_get(&block->block->cache, block);
    ||if (got != NULL) {
        | mov32q64 RAX, ((uint64_t) (got))
        | jmp rax
    ||} else if (!block->block->mark) {
        ||got = vm_jit_rblock(state, block, false);
        | mov32q64 RAX, ((uint64_t) (got))
        | jmp rax
    ||} else {
        ||void **bit = vm_malloc(sizeof(void *));
        ||*bit = NULL;
        | mov32q64 RCX, ((uint64_t) (bit))
        | mov rax, [rcx]
        | test rax, rax
        |jnz >9
        | mov32q64 rArg0, ((uint64_t) state)
        | mov32q64 rArg1, ((uint64_t) block)
        | mov Rd(rArg2), 0
        | invoke vm_jit_rblock
        | mov32q64 RCX, ((uint64_t) (bit))
        | mov [rcx], rax
        |9:
        | jmp rax
    ||}
|| }
|.endmacro

|.macro invoke_code, func
    || {
    || void *ptr = (void*) (func);
    | mov32q64 RAX, ((uint64_t) (ptr))
    | call rax
    || }
|.endmacro

|.macro vmfrax, arg1
|| {
    ||vm_rblock_t *block = arg1;
    ||block->isfunc = true;
    ||void *got = vm_cache_get(&block->block->cache, block);
    ||if (got != NULL) {
        | mov32q64 RAX, ((uint64_t) (got))
    ||} else if (!block->block->mark) {
        ||got = vm_jit_rblock(state, block, true);
        | mov32q64 RAX, ((uint64_t) (got))
    ||} else {
        ||void **bit = vm_malloc(sizeof(void *));
        ||*bit = NULL;
        | mov32q64 RCX, ((uint64_t) (bit))
        | mov rax, [rcx]
        | test rax, rax
        |jnz >9
        | mov32q64 rArg0, ((uint64_t) state)
        | mov32q64 rArg1, ((uint64_t) block)
        | mov Rd(rArg2), 1
        | invoke vm_jit_rblock
        | mov32q64 RCX, ((uint64_t) (bit))
        | mov [rcx], rax
        |9:
    ||}
|| }
|.endmacro

|.macro vmload8, arg1, arg2
|| {
    || vm_arg_t arg = arg2;
    || if (arg.type == VM_ARG_REG) {
        | mov Rb(arg1), [rsp + (8 * arg.reg)]
    || } else if (arg.type == VM_ARG_NUM) {
        || int8_t n = (int8_t) arg.num;
        | mov Rb(arg1), n
    ||}
|| }
|.endmacro

|.macro vmload16, arg1, arg2
|| {
    || vm_arg_t arg = arg2;
    || if (arg.type == VM_ARG_REG) {
        | mov Rw(arg1), [rsp + (8 * arg.reg)]
    || } else if (arg.type == VM_ARG_NUM) {
        || int16_t n = (int16_t) arg.num;
        | mov Rw(arg1), n
    ||}
|| }
|.endmacro

|.macro vmload32, arg1, arg2
|| {
    || vm_arg_t arg = arg2;
    || if (arg.type == VM_ARG_REG) {
        | mov Rd(arg1), [rsp + (8 * arg.reg)]
    || } else if (arg.type == VM_ARG_NUM) {
        || int32_t n = (int32_t) arg.num;
        | mov Rd(arg1), n
    ||}
|| }
|.endmacro

|.macro vmload64, arg1, arg2
|| {
    || vm_arg_t arg = arg2;
    || if (arg.type == VM_ARG_REG) {
        | mov Rq(arg1), [rsp + (8 * arg.reg)]
    || } else if (arg.type == VM_ARG_NUM) {
        || int64_t n = (int64_t) arg.num;
        || int32_t t = (int32_t) n;
        || if (n == (int64_t) t) {
            | mov Rd(arg1), n
        || } else {
            | mov64 Rq(arg1), n
        || }
    ||}
|| }
|.endmacro

|.macro vmstore8, arg1, arg2
|| {
    | mov [rsp + (8 * (arg1).reg)], Rb(arg2)
|| }
|.endmacro

|.macro vmstore16, arg1, arg2
|| {
    | mov [rsp + (8 * (arg1).reg)], Rw(arg2)
|| }
|.endmacro

|.macro vmstore32, arg1, arg2
|| {
    | mov [rsp + (8 * (arg1).reg)], Rd(arg2)
|| }
|.endmacro

|.macro vmstore64, arg1, arg2
|| {
    | mov [rsp + (8 * (arg1).reg)], Rq(arg2)
|| }
|.endmacro

|.macro check, instr, size, av1, av2
|| {
    || vm_arg_t arg1 = av1;
    || vm_arg_t arg2 = av2;
    || if (arg2.type == VM_ARG_NUM) {
        | vmload..size RAX, arg1
        || switch (size) {
        || case 8: {
            | instr al, ((int8_t) arg2.num)
            || break;
        || }
        || case 16: {
            | instr ax, ((int16_t) arg2.num)
            || break;
        || }
        || case 32: {
            | instr eax, ((int32_t) arg2.num)
            || break;
        || }
        || case 64: {
            || int64_t n = (int64_t) arg2.num;
            || int32_t t = (int32_t) n;
            || if (n == (int64_t) t) {
                | instr rax, t
            || } else {
                | mov64 rcx, n
                | instr rax, rcx
            || }
            || break;
        || }
        || }
    || } else {
        | vmload..size RAX, arg1
        | vmload..size RCX, arg2
        || switch (size) {
        || case 8: {
            | instr al, cl
            || break;
        || }
        || case 16: {
            | instr ax, cx
            || break;
        || }
        || case 32: {
            | instr eax, ecx
            || break;
        || }
        || case 64: {
            | instr rax, rcx
            || break;
        || }
        || }
    || }
|| }
|.endmacro

void vm_jit_putchar(ptrdiff_t c) {
    printf("%c", (char) c);
}

static void* vm_jit_encode(vm_jit_state_t *state, dasm_State** d)
{
    size_t size;
    dasm_link(d, &size);
#ifdef _WIN32
    void* buf = VirtualAlloc(0, size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
#else
    vm_jit_mmap_t *map = NULL;
    for (size_t i = 0; i < state->mapbuf.len; i++) {
        vm_jit_mmap_t *cur = &state->mapbuf.mmaps[state->mapbuf.len - i - 1];
        if (cur->used + size <= cur->alloc) {
            map = cur;
            break;
        }
    }
    // printf("%p / %zu", map, state->mapbuf.len);
    void *buf = NULL;
    if (map == NULL) {
        size_t blocks = 1;
        if (state->mapbuf.len < 12) {
            blocks = 1 << state->mapbuf.len;
        } else {
            blocks = 1 << 12;
        }
        size_t minsize = 4096 * blocks;
        size_t next_index = state->mapbuf.len + 1;
        if (next_index >= state->mapbuf.alloc) {
            state->mapbuf.alloc += next_index * 2;
            state->mapbuf.mmaps = vm_realloc(state->mapbuf.mmaps, sizeof(vm_jit_mmap_t) * state->mapbuf.alloc);
        }
        if (size < minsize) {
            map = &state->mapbuf.mmaps[next_index - 1];
            map->alloc = minsize;
            state->mapbuf.len = next_index;
            map->mem = mmap(0, map->alloc, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS | MAP_32BIT, -1, 0);
            map->used = size;
            buf = map->mem;
        } else {
            buf = mmap(0, map->alloc, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS | MAP_32BIT, -1, 0);
        }
    } else {
        buf = (void *) (((size_t) (map->mem)) + map->used);
        map->used += size;
    }
    
#endif
    dasm_encode(d, buf);
#ifdef _WIN32
    DWORD dwOld;
    VirtualProtect(buf, size, PAGE_EXECUTE_READ, &dwOld);
#endif
    // char chrs[256];
    // sprintf(chrs, "%p.bin", buf);
    // // static FILE *f = NULL;
    // FILE *f = NULL;
    // if (f == NULL) {
    //     f = fopen(chrs, "wb");
    // }
    // fwrite(buf, size, 1, f);
    // fclose(f);
    return buf;
}

static const uint8_t argregs[6] = {rArg0, rArg1, rArg2, rArg3, rArg4, rArg5};

static void vm_jit_rblock_single(vm_jit_state_t *state, dasm_State **Dst, vm_rblock_t *rnext) {
    for (size_t ninstr = rnext->start; ninstr < rnext->block->len; ninstr++) {
        vm_instr_t instr = vm_rblock_type_specialize_instr(rnext->regs, rnext->block->instrs[ninstr]);
        if (!vm_rblock_type_check_instr(rnext->regs, instr)) __builtin_trap();
        switch (instr.op) {
        case VM_IOP_NOP: {
            break;
        }
        case VM_IOP_MOVE: {
            if (instr.args[0].type == VM_ARG_NUM) {
                int64_t n = instr.args[0].num;
                switch (instr.tag) {
                case VM_TAG_I8:
                case VM_TAG_U8:{
                    | mov byte [rsp + (8 * instr.out.reg)], ((int8_t) n)
                    break;
                }
                case VM_TAG_I16:
                case VM_TAG_U16: {
                    | mov word [rsp + (8 * instr.out.reg)], ((int16_t) n)
                    break;
                }
                case VM_TAG_I32:
                case VM_TAG_U32: {
                    | mov dword [rsp + (8 * instr.out.reg)], ((int32_t) n)
                    break;
                }
                case VM_TAG_I64:
                case VM_TAG_U64: {
                    int32_t t = (int64_t) n;
                    if (n == (int64_t) t) {
                        | mov qword [rsp + (8 * instr.out.reg)], n
                    } else {
                        | mov64 rax, n
                        | mov qword [rsp + (8 * instr.out.reg)], rax
                    }
                    break;
                }
                default: {
                    __builtin_trap();
                }
                }
            } else if (instr.args[0].type == VM_ARG_REG) {
                switch (instr.tag) {
                case VM_TAG_I8:
                case VM_TAG_U8:{
                    | vmload8 RAX, instr.args[0]
                    | vmstore8 instr.out, RAX
                    break;
                }
                case VM_TAG_I16:
                case VM_TAG_U16: {
                    | vmload16 RAX, instr.args[0]
                    | vmstore16 instr.out, RAX
                    break;
                }
                case VM_TAG_I32:
                case VM_TAG_U32: {
                    | vmload32 RAX, instr.args[0]
                    | vmstore32 instr.out, RAX
                    break;
                }
                case VM_TAG_I64:
                case VM_TAG_U64: {
                    | vmload64 RAX, instr.args[0]
                    | vmstore64 instr.out, RAX
                    break;
                }
                default: {
                    __builtin_trap();
                }
                }
            }
            // | vmload64 RAX, instr.args[0]
            // | vmstore64 instr.out, RAX
            break;
        }
        case VM_IOP_CAST: {
            break;
        }
        case VM_IOP_ADD: {
            switch (instr.tag) {
            case VM_TAG_I8:
            case VM_TAG_U8:{
                if (instr.args[0].type == VM_ARG_REG && instr.out.reg == instr.args[0].reg) {
                    if (instr.args[1].type == VM_ARG_NUM) {
                        if (instr.tag ==  VM_TAG_I8) {
                            | add byte [rsp + (8 * instr.out.reg)], ((int8_t) (instr.args[1].num))
                        } else {
                            | add byte [rsp + (8 * instr.out.reg)], ((uint8_t) (instr.args[1].num))
                        }
                    } else {
                        | vmload8 RAX, instr.args[1]
                        | add byte [rsp + (8 * instr.out.reg)], al
                    }
                } else {
                    if (instr.args[1].type == VM_ARG_NUM) {
                        | vmload8 RAX, instr.args[0]
                        if (instr.tag ==  VM_TAG_I8) {
                            | add al, ((int8_t) (instr.args[1].num))
                        } else {
                            | add al, ((uint8_t) (instr.args[1].num))
                        }
                        | vmstore8 instr.out, RAX
                    } else {
                        | vmload8 RAX, instr.args[0]
                        if (instr.tag ==  VM_TAG_I8) {
                            | add al, byte [rsp + (8 * instr.args[1].reg)]
                        } else {
                            | add al, byte [rsp + (8 * instr.args[1].reg)]
                        }
                        | vmstore8 instr.out, RAX
                    }
                }
                break;
            }
            case VM_TAG_I16:
            case VM_TAG_U16:{
                if (instr.args[0].type == VM_ARG_REG && instr.out.reg == instr.args[0].reg) {
                    if (instr.args[1].type == VM_ARG_NUM) {
                        if (instr.tag ==  VM_TAG_I8) {
                            | add word [rsp + (8 * instr.out.reg)], ((int16_t) (instr.args[1].num))
                        } else {
                            | add word [rsp + (8 * instr.out.reg)], ((uint16_t) (instr.args[1].num))
                        }
                    } else {
                        | vmload16 RAX, instr.args[1]
                        | add word [rsp + (8 * instr.out.reg)], ax
                    }
                } else {
                    if (instr.args[1].type == VM_ARG_NUM) {
                        | vmload16 RAX, instr.args[0]
                        if (instr.tag ==  VM_TAG_I8) {
                            | add ax, ((int64_t) (instr.args[1].num))
                        } else {
                            | add ax, ((uint64_t) (instr.args[1].num))
                        }
                        | vmstore16 instr.out, RAX
                    } else {
                        | vmload16 RAX, instr.args[0]
                        if (instr.tag ==  VM_TAG_I8) {
                            | add ax, word [rsp + (8 * instr.args[1].reg)]
                        } else {
                            | add ax, word [rsp + (8 * instr.args[1].reg)]
                        }
                        | vmstore16 instr.out, RAX
                    }
                }
                break;
            }
            case VM_TAG_I32:
            case VM_TAG_U32: {
                if (instr.args[0].type == VM_ARG_REG && instr.out.reg == instr.args[0].reg) {
                    if (instr.args[1].type == VM_ARG_NUM) {
                        if (instr.tag ==  VM_TAG_I8) {
                            | add dword [rsp + (8 * instr.out.reg)], ((int32_t) (instr.args[1].num))
                        } else {
                            | add dword [rsp + (8 * instr.out.reg)], ((uint32_t) (instr.args[1].num))
                        }
                    } else {
                        | vmload32 RAX, instr.args[1]
                        | add dword [rsp + (8 * instr.out.reg)], eax
                    }
                } else {
                    if (instr.args[1].type == VM_ARG_NUM) {
                        | vmload32 RAX, instr.args[0]
                        if (instr.tag ==  VM_TAG_I8) {
                            | add eax, ((int64_t) (instr.args[1].num))
                        } else {
                            | add eax, ((uint64_t) (instr.args[1].num))
                        }
                        | vmstore32 instr.out, RAX
                    } else {
                        | vmload32 RAX, instr.args[0]
                        if (instr.tag ==  VM_TAG_I8) {
                            | add eax, dword [rsp + (8 * instr.args[1].reg)]
                        } else {
                            | add eax, dword [rsp + (8 * instr.args[1].reg)]
                        }
                        | vmstore32 instr.out, RAX
                    }
                }
                break;
            }
            case VM_TAG_I64:
            case VM_TAG_U64: {
                if (instr.args[0].type == VM_ARG_REG && instr.out.reg == instr.args[0].reg) {
                    if (instr.args[1].type == VM_ARG_NUM) {
                        if (instr.tag ==  VM_TAG_I8) {
                            | add qword [rsp + (8 * instr.out.reg)], ((int64_t) (instr.args[1].num))
                        } else {
                            | add qword [rsp + (8 * instr.out.reg)], ((uint64_t) (instr.args[1].num))
                        }
                    } else {
                        | vmload64 RAX, instr.args[1]
                        | add qword [rsp + (8 * instr.out.reg)], rax
                    }
                } else {
                    if (instr.args[1].type == VM_ARG_NUM) {
                        | vmload64 RAX, instr.args[0]
                        if (instr.tag ==  VM_TAG_I8) {
                            | add rax, ((int64_t) (instr.args[1].num))
                        } else {
                            | add rax, ((uint64_t) (instr.args[1].num))
                        }
                        | vmstore64 instr.out, RAX
                    } else {
                        | vmload64 RAX, instr.args[0]
                        if (instr.tag ==  VM_TAG_I8) {
                            | add rax, qword [rsp + (8 * instr.args[1].reg)]
                        } else {
                            | add rax, qword [rsp + (8 * instr.args[1].reg)]
                        }
                        | vmstore64 instr.out, RAX
                    }
                }
                break;
            }
            default: {
                __builtin_trap();
            }
            }
            break;
        }
        case VM_IOP_SUB: {
            switch (instr.tag) {
            case VM_TAG_I8:
            case VM_TAG_U8:{
                if (instr.args[0].type == VM_ARG_REG && instr.out.reg == instr.args[0].reg) {
                    if (instr.args[1].type == VM_ARG_NUM) {
                        if (instr.tag ==  VM_TAG_I8) {
                            | sub byte [rsp + (8 * instr.out.reg)], ((int8_t) (instr.args[1].num))
                        } else {
                            | sub byte [rsp + (8 * instr.out.reg)], ((uint8_t) (instr.args[1].num))
                        }
                    } else {
                        | vmload8 RAX, instr.args[1]
                        | sub byte [rsp + (8 * instr.out.reg)], al
                    }
                } else {
                    if (instr.args[1].type == VM_ARG_NUM) {
                        | vmload8 RAX, instr.args[0]
                        if (instr.tag ==  VM_TAG_I8) {
                            | sub al, ((int8_t) (instr.args[1].num))
                        } else {
                            | sub al, ((uint8_t) (instr.args[1].num))
                        }
                        | vmstore8 instr.out, RAX
                    } else {
                        | vmload8 RAX, instr.args[0]
                        if (instr.tag ==  VM_TAG_I8) {
                            | sub al, byte [rsp + (8 * instr.args[1].reg)]
                        } else {
                            | sub al, byte [rsp + (8 * instr.args[1].reg)]
                        }
                        | vmstore8 instr.out, RAX
                    }
                }
                break;
            }
            case VM_TAG_I16:
            case VM_TAG_U16:{
                if (instr.args[0].type == VM_ARG_REG && instr.out.reg == instr.args[0].reg) {
                    if (instr.args[1].type == VM_ARG_NUM) {
                        if (instr.tag ==  VM_TAG_I8) {
                            | sub word [rsp + (8 * instr.out.reg)], ((int16_t) (instr.args[1].num))
                        } else {
                            | sub word [rsp + (8 * instr.out.reg)], ((uint16_t) (instr.args[1].num))
                        }
                    } else {
                        | vmload16 RAX, instr.args[1]
                        | sub word [rsp + (8 * instr.out.reg)], ax
                    }
                } else {
                    if (instr.args[1].type == VM_ARG_NUM) {
                        | vmload16 RAX, instr.args[0]
                        if (instr.tag ==  VM_TAG_I8) {
                            | sub ax, ((int64_t) (instr.args[1].num))
                        } else {
                            | sub ax, ((uint64_t) (instr.args[1].num))
                        }
                        | vmstore16 instr.out, RAX
                    } else {
                        | vmload16 RAX, instr.args[0]
                        if (instr.tag ==  VM_TAG_I8) {
                            | sub ax, word [rsp + (8 * instr.args[1].reg)]
                        } else {
                            | sub ax, word [rsp + (8 * instr.args[1].reg)]
                        }
                        | vmstore16 instr.out, RAX
                    }
                }
                break;
            }
            case VM_TAG_I32:
            case VM_TAG_U32: {
                if (instr.args[0].type == VM_ARG_REG && instr.out.reg == instr.args[0].reg) {
                    if (instr.args[1].type == VM_ARG_NUM) {
                        if (instr.tag ==  VM_TAG_I8) {
                            | sub dword [rsp + (8 * instr.out.reg)], ((int32_t) (instr.args[1].num))
                        } else {
                            | sub dword [rsp + (8 * instr.out.reg)], ((uint32_t) (instr.args[1].num))
                        }
                    } else {
                        | vmload32 RAX, instr.args[1]
                        | sub dword [rsp + (8 * instr.out.reg)], eax
                    }
                } else {
                    if (instr.args[1].type == VM_ARG_NUM) {
                        | vmload32 RAX, instr.args[0]
                        if (instr.tag ==  VM_TAG_I8) {
                            | sub eax, ((int64_t) (instr.args[1].num))
                        } else {
                            | sub eax, ((uint64_t) (instr.args[1].num))
                        }
                        | vmstore32 instr.out, RAX
                    } else {
                        | vmload32 RAX, instr.args[0]
                        if (instr.tag ==  VM_TAG_I8) {
                            | sub eax, dword [rsp + (8 * instr.args[1].reg)]
                        } else {
                            | sub eax, dword [rsp + (8 * instr.args[1].reg)]
                        }
                        | vmstore32 instr.out, RAX
                    }
                }
                break;
            }
            case VM_TAG_I64:
            case VM_TAG_U64: {
                if (instr.args[0].type == VM_ARG_REG && instr.out.reg == instr.args[0].reg) {
                    if (instr.args[1].type == VM_ARG_NUM) {
                        if (instr.tag ==  VM_TAG_I8) {
                            | sub qword [rsp + (8 * instr.out.reg)], ((int64_t) (instr.args[1].num))
                        } else {
                            | sub qword [rsp + (8 * instr.out.reg)], ((uint64_t) (instr.args[1].num))
                        }
                    } else {
                        | vmload64 RAX, instr.args[1]
                        | sub qword [rsp + (8 * instr.out.reg)], rax
                    }
                } else {
                    if (instr.args[1].type == VM_ARG_NUM) {
                        | vmload64 RAX, instr.args[0]
                        if (instr.tag ==  VM_TAG_I8) {
                            | sub rax, ((int64_t) (instr.args[1].num))
                        } else {
                            | sub rax, ((uint64_t) (instr.args[1].num))
                        }
                        | vmstore64 instr.out, RAX
                    } else {
                        | vmload64 RAX, instr.args[0]
                        if (instr.tag ==  VM_TAG_I8) {
                            | sub rax, qword [rsp + (8 * instr.args[1].reg)]
                        } else {
                            | sub rax, qword [rsp + (8 * instr.args[1].reg)]
                        }
                        | vmstore64 instr.out, RAX
                    }
                }
                break;
            }
            default: {
                __builtin_trap();
            }
            }
            break;
        }
        case VM_IOP_MUL: {
            switch (instr.tag) {
            case VM_TAG_I8:
            case VM_TAG_U8: {
                | vmload8 RAX, instr.args[0]
                | vmload8 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I8) {
                    | imul cl
                } else {
                    | mul cl
                }
                | vmstore8 instr.out, RAX
                break;
            }
            case VM_TAG_I16:
            case VM_TAG_U16: {
                | vmload16 RAX, instr.args[0]
                | vmload16 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I16) {
                    | imul cx
                } else {
                    | mul cx
                }
                | vmstore16 instr.out, RAX
                break;
            }
            case VM_TAG_I32:
            case VM_TAG_U32: {
                | vmload32 RAX, instr.args[0]
                | vmload32 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I32) {
                    | imul ecx
                } else {
                    | mul ecx
                }
                | vmstore32 instr.out, RAX
                break;
            }
            case VM_TAG_I64:
            case VM_TAG_U64: {
                | vmload64 RAX, instr.args[0]
                | vmload64 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I64) {
                    | imul rcx
                } else {
                    | mul rcx
                }
                | vmstore64 instr.out, RAX
                break;
            }
            default: {
                __builtin_trap();
            }
            }
            break;
        }
        case VM_IOP_DIV: {
            switch (instr.tag) {
            case VM_TAG_I8:
            case VM_TAG_U8: {
                | xor ax, ax
                | vmload8 RAX, instr.args[0]
                | vmload8 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I8) {
                    | idiv cl
                } else {
                    | div cl
                }
                | vmstore8 instr.out, RAX
                break;
            }
            case VM_TAG_I16:
            case VM_TAG_U16: {
                | xor dx, dx
                | vmload16 RAX, instr.args[0]
                | vmload16 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I16) {
                    | idiv cx
                } else {
                    | div cx
                }
                | vmstore16 instr.out, RAX
                break;
            }
            case VM_TAG_I32:
            case VM_TAG_U32: {
                | xor edx, edx
                | vmload32 RAX, instr.args[0]
                | vmload32 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I32) {
                    | idiv ecx
                } else {
                    | div ecx
                }
                | vmstore32 instr.out, RAX
                break;
            }
            case VM_TAG_I64:
            case VM_TAG_U64: {
                | xor edx, edx
                | vmload64 RAX, instr.args[0]
                | vmload64 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I64) {
                    | idiv rcx
                } else {
                    | div rcx
                }
                | vmstore64 instr.out, RAX
                break;
            }
            default: {
                __builtin_trap();
            }
            }
            break;
        }
        case VM_IOP_MOD: {
            switch (instr.tag) {
            case VM_TAG_I8:
            case VM_TAG_U8: {
                | xor ax, ax
                | vmload8 RAX, instr.args[0]
                | vmload8 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I8) {
                    | idiv cl
                } else {
                    | div cl
                }
                | mov dl, ah
                | vmstore8 instr.out, RDX
                break;
            }
            case VM_TAG_I16:
            case VM_TAG_U16: {
                | xor dx, dx
                | vmload16 RAX, instr.args[0]
                | vmload16 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I16) {
                    | idiv cx
                } else {
                    | div cx
                }
                | vmstore16 instr.out, RDX
                break;
            }
            case VM_TAG_I32:
            case VM_TAG_U32: {
                | xor edx, edx
                | vmload32 RAX, instr.args[0]
                | vmload32 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I32) {
                    | idiv ecx
                } else {
                    | div ecx
                }
                | vmstore32 instr.out, RDX
                break;
            }
            case VM_TAG_I64:
            case VM_TAG_U64: {
                | xor edx, edx
                | vmload64 RAX, instr.args[0]
                | vmload64 RCX, instr.args[1]
                if (instr.tag == VM_TAG_I64) {
                    | idiv rcx
                } else {
                    | div rcx
                }
                | vmstore64 instr.out, RDX
                break;
            }
            default: {
                __builtin_trap();
            }
            }
            break;
        }
        case VM_IOP_CALL: {
            if (instr.args[0].type == VM_ARG_FUNC) {
                vm_tags_t *argtypes = vm_rblock_regs_empty(VM_NREGS);
                for (size_t i = 1; instr.args[i].type != VM_ARG_NONE; i++) {
                    argtypes->tags[i] = rnext->regs->tags[instr.args[i].reg];
                }
                vm_rblock_t *func = vm_rblock_new(instr.args[0].func, argtypes);
                |vmfrax func
                for (int32_t i = 1; instr.args[i].type != VM_ARG_NONE; i++) {
                    switch (rnext->regs->tags[instr.args[i].reg]) {
                        case VM_TAG_I8:
                        case VM_TAG_U8: {
                            | vmload8 argregs[i-1], instr.args[i] 
                            break;
                        }
                        case VM_TAG_I16:
                        case VM_TAG_U16: {
                            | vmload16 argregs[i-1], instr.args[i] 
                            break;
                        }
                        case VM_TAG_I32:
                        case VM_TAG_U32: {
                            | vmload32 argregs[i-1], instr.args[i] 
                            break;
                        }
                        case VM_TAG_I64:
                        case VM_TAG_U64: {
                            | vmload64 argregs[i-1], instr.args[i] 
                            break;
                        }
                        default: {
                            __builtin_trap();
                        }
                    }
                }
                | call rax
                | vmstore64 instr.out, RAX
            }
            break;
        }
        case VM_IOP_OUT: {
            | xor Rd(rArg0), Rd(rArg0)
            switch (instr.tag) {
            case VM_TAG_I8:
            case VM_TAG_U8: {
                | vmload8 rArg0, instr.args[0]
                break;
            }
            case VM_TAG_I16:
            case VM_TAG_U16: {
                | vmload16 rArg0, instr.args[0]
                break;
            }
            case VM_TAG_I32:
            case VM_TAG_U32: {
                | vmload32 rArg0, instr.args[0]
                break;
            }
            case VM_TAG_I64:
            case VM_TAG_U64: {
                | vmload64 rArg0, instr.args[0]
                break;
            }
            default: {
                __builtin_trap();
            }
            }
            | invoke vm_jit_putchar
            break;
        }
        case VM_IOP_IN: {
            printf("IN\n");
            break;
        }
        case VM_IOP_BNOT: {
            break;
        }
        case VM_IOP_BOR: {
            break;
        }
        case VM_IOP_BAND: {
            break;
        }
        case VM_IOP_BXOR: {
            break;
        }
        case VM_IOP_BSHL: {
            break;
        }
        case VM_IOP_BSHR: {
            break;
        }
        }
        if (instr.out.type == VM_ARG_REG) {
            rnext->regs->tags[instr.out.reg] = instr.tag;
        }
    }
    vm_branch_t branch = vm_rblock_type_specialize_branch(rnext->regs, rnext->block->branch);
    if (!vm_rblock_type_check_branch(rnext->regs, branch)) __builtin_trap();
    // switch (branch.op) {
    // case VM_BOP_EXIT: {
    //     break;
    // }
    // case VM_BOP_RET: {
    //     break;
    // }
    // case VM_BOP_JUMP: {
    //     if (rnext->targets[0] == NULL) {
    //         rnext->targets[0] = vm_rblock_new(branch.targets[0], rnext->regs);
    //     }
    //     break;
    // }
    // case VM_BOP_BB: {
    //     if (rnext->targets[0] == NULL) {
    //         rnext->targets[0] = vm_rblock_new(branch.targets[0], rnext->regs);
    //     }
    //     if (rnext->targets[1] == NULL) {
    //         rnext->targets[1] = vm_rblock_new(branch.targets[1], rnext->regs);
    //     }
    //     break;
    // }
    // case VM_BOP_BEQ: {
    //     if (rnext->targets[0] == NULL) {
    //         rnext->targets[0] = vm_rblock_new(branch.targets[0], rnext->regs);
    //     }
    //     if (rnext->targets[1] == NULL) {
    //         rnext->targets[1] = vm_rblock_new(branch.targets[1], rnext->regs);
    //     }
    //     break;
    // }
    // case VM_BOP_BLT: {
    //     if (rnext->targets[0] == NULL) {
    //         rnext->targets[0] = vm_rblock_new(branch.targets[0], rnext->regs);
    //     }
    //     if (rnext->targets[1] == NULL) {
    //         rnext->targets[1] = vm_rblock_new(branch.targets[1], rnext->regs);
    //     }
    //     break;
    // }
    // }
    switch (branch.op) {
    case VM_BOP_EXIT: {
        | mov64 rax, ((uint64_t) &state->exitptr)
        | mov rsp, [rax]
        | pop rbp
        | ret
        break;
    }
    case VM_BOP_RET: {
        switch (branch.tag) {
        case VM_TAG_I8:
        case VM_TAG_U8: {
            | vmload8 RAX, branch.args[0]
            break;
        }
        case VM_TAG_I16:
        case VM_TAG_U16: {
            | vmload16 RAX, branch.args[0]
            break;
        }
        case VM_TAG_I32:
        case VM_TAG_U32: {
            | vmload32 RAX, branch.args[0]
            break;
        }
        case VM_TAG_I64:
        case VM_TAG_U64: {
            | vmload64 RAX, branch.args[0]
            break;
        }
        }
        | mov rsp, rbp
        | pop rbp
        | ret
        break;
    }
    case VM_BOP_JUMP: {
        | vmjump vm_rblock_new(branch.targets[0], rnext->regs)
        break;
    }
    case VM_BOP_BB: {
        switch (branch.tag) {
        case VM_TAG_I8:
        case VM_TAG_U8: {
            | vmload8 RAX, branch.args[0]
            | test al, al
            break;
        }
        case VM_TAG_I16:
        case VM_TAG_U16: {
            | vmload16 RAX, branch.args[0]
            | test ax, ax
            break;
        }
        case VM_TAG_I32:
        case VM_TAG_U32: {
            | vmload32 RAX, branch.args[0]
            | test eax, eax
            break;
        }
        case VM_TAG_I64:
        case VM_TAG_U64: {
            | vmload64 RAX, branch.args[0]
            | test rax, rax
            break;
        }
        }
        | jnz >1
        | vmjump vm_rblock_new(branch.targets[1], rnext->regs)
        |1:
        | vmjump vm_rblock_new(branch.targets[0], rnext->regs)
        break;
    }
    case VM_BOP_BEQ: {
        switch (branch.tag) {
        case VM_TAG_I8:
        case VM_TAG_U8: {
            | check cmp, 8, (branch.args[0]), (branch.args[1])
            break;
        }
        case VM_TAG_I16:
        case VM_TAG_U16: {
            | check cmp, 16, (branch.args[0]), (branch.args[1])
            break;
        }
        case VM_TAG_I32:
        case VM_TAG_U32: {
            | check cmp, 32, (branch.args[0]), (branch.args[1])
            break;
        }
        case VM_TAG_I64:
        case VM_TAG_U64: {
            | check cmp, 64, (branch.args[0]), (branch.args[1])
            break;
        }
        }
        | je >1
        | vmjump vm_rblock_new(branch.targets[1], rnext->regs)
        |1:
        | vmjump vm_rblock_new(branch.targets[0], rnext->regs)
        break;
    }
    case VM_BOP_BLT: {
        switch (branch.tag) {
        case VM_TAG_I8:
        case VM_TAG_U8: {
            | check cmp, 8, (branch.args[0]), (branch.args[1])
            break;
        }
        case VM_TAG_I16:
        case VM_TAG_U16: {
            | check cmp, 16, (branch.args[0]), (branch.args[1])
            break;
        }
        case VM_TAG_I32:
        case VM_TAG_U32: {
            | check cmp, 32, (branch.args[0]), (branch.args[1])
            break;
        }
        case VM_TAG_I64:
        case VM_TAG_U64: {
            | check cmp, 64, (branch.args[0]), (branch.args[1])
            break;
        }
        }
        switch (branch.tag) {
        case VM_TAG_I8:
        case VM_TAG_I16:
        case VM_TAG_I32:
        case VM_TAG_I64: {
            | jl >1
            break;
        }
        case VM_TAG_U8:
        case VM_TAG_U16:
        case VM_TAG_U32:
        case VM_TAG_U64: {
            | jb >1
            break;
        }
        }
        | vmjump vm_rblock_new(branch.targets[1], rnext->regs)
        |1:
        | vmjump vm_rblock_new(branch.targets[0], rnext->regs)
        break;
    }
    }
    // state->depth -= 1;
}

#define Dst (&d)

static void *vm_jit_rblock(vm_jit_state_t *state, vm_rblock_t *rblock, bool isfunc) {
    size_t count = state->count++;
    void *cached = vm_cache_get(&rblock->block->cache, rblock);
    if (cached != NULL) {
        return cached;
    }
    bool last_mark = rblock->block->mark;
    rblock->block->mark = true;
    dasm_State* d;
    |.section code
    dasm_init(&d, DASM_MAXSECTION);
    |.globals lbl_
    void* labels[lbl__MAX];
    dasm_setupglobal(&d, labels, lbl__MAX);
    |.actionlist act
    dasm_setup(&d, act);
    dasm_growpc(&d, 16);
    |.code
    |->main:
    size_t nregs = rblock->block->nregs;
    if (nregs < rblock->block->nargs + 1) {
        nregs = rblock->block->nargs + 1;
    }
    if (count == 0) {
        size_t push = 0;
        | push rbp
        push++;
        | mov rbp, rsp
        | mov64 rax, ((uint64_t) &state->exitptr)
        | mov [rax], rsp
        if ((nregs + push) % 2 == 0) {
            | sub rsp, nregs * 8 + 8
        } else {
            | sub rsp, nregs * 8
        }
    } else if (isfunc) {
        size_t push = 0;
        | push rbp
        push++;
        | mov rbp, rsp
        if ((nregs + push) % 2 == 0) {
            | sub rsp, nregs * 8 + 8
        } else {
            | sub rsp, nregs * 8
        }
        for (size_t i = 0; i < rblock->block->nargs; i++) {
            size_t reg = i+1;
            switch (rblock->regs->tags[reg]) {
                case VM_TAG_I8:
                case VM_TAG_U8: {
                    | mov byte [rsp + (8 * reg)], Rb(argregs[i])
                    break;
                }
                case VM_TAG_I16:
                case VM_TAG_U16: {
                    | mov word [rsp + (8 * reg)], Rw(argregs[i])
                    break;
                }
                case VM_TAG_I32:
                case VM_TAG_U32: {
                    | mov dword [rsp + (8 * reg)], Rd(argregs[i])
                    break;
                }
                case VM_TAG_I64:
                case VM_TAG_U64: {
                    | mov qword [rsp + (8 * reg)], Rq(argregs[i])
                    break;
                }
            }
        }
    }
    vm_tags_t *types = vm_rblock_regs_dup(rblock->regs, VM_NREGS);
    vm_rblock_t *rnext = vm_rblock_new(rblock->block, types);
    rnext->start = rblock->start;
    rnext->isfunc = isfunc;
    vm_jit_rblock_single(state, &d, rnext);
    vm_jit_encode(state, &d);
    dasm_free(&d);
    void *fn = labels[lbl_main];
    vm_cache_set(&rblock->block->cache, rnext, fn);
    rblock->block->mark = last_mark;
    return fn;
}

vm_jit_state_t *vm_jit_state_new(void) {
    vm_jit_state_t *ret = vm_malloc(sizeof(vm_jit_state_t));
    *ret = (vm_jit_state_t) {0};
    return ret;
}

void vm_jit_state_free(vm_jit_state_t *state) {
    vm_free(state);
}

void vm_jit_run(void *state_ptr, vm_block_t *block) {
    vm_jit_state_t *state = state_ptr;
    vm_rblock_t *rblock = vm_rblock_new(block, vm_rblock_regs_empty(block->nregs));
    size_t(*fn)(void) = vm_jit_rblock(state, rblock, true);
    fn();
    state->count = 0;
}
