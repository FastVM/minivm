
#include "jit.h"
#include "../../int/gc.h"

#include "../../../luajit/dynasm/dasm_proto.h"
#include "../../../luajit/dynasm/dasm_x86.h"

#if _WIN32
#include <Windows.h>
#else
#include <sys/mman.h>
#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
#define MAP_ANONYMOUS MAP_ANON
#endif
#endif

void vm_printn(size_t n)
{
    printf("debug: %zu\n", n);
}

size_t vm_ir_be_jit_len(vm_gc_t *gc, vm_value_t ptr)
{
    return vm_gc_len(gc, ptr) << 1;
}

size_t vm_ir_be_jit_alloc(vm_gc_t *gc, size_t ptr)
{
    return (vm_gc_arr(gc, ptr >> 1) << 1) | 1;
}

vm_value_t vm_ir_be_jit_get(vm_gc_t *gc, vm_value_t ptr, vm_value_t val)
{
    return vm_gc_get_v(gc, ptr, val);
}

void vm_ir_be_jit_set(vm_gc_t *gc, vm_value_t ptr, vm_value_t nth, vm_value_t val)
{
    vm_gc_set_vv(gc, ptr, nth, val);
}


|.arch x64

|.define vmRegTmp1, r8
|.define vmRegTmp2, r9
|.define vmArg1, rdi
|.define vmArg2, rsi
|.define vmArg3, rdx
|.define vmArg4, rcx

|.define vmRegStack, vmArg1

|.macro pusha
| push vmArg1
| push vmRegTmp1
| push vmRegTmp2
|.endmacro

|.macro popa
| pop vmRegTmp2
| pop vmRegTmp1
| pop vmArg1
|.endmacro

|.macro vmLoad, x64reg, vmReg
| mov x64reg, qword [vmRegStack + (vmReg) * sizeof(size_t)]
|.endmacro

|.macro vmStore, vmReg, x64reg
| mov qword [vmRegStack + (vmReg) * sizeof(size_t)], x64reg
|.endmacro

|.macro vmPrintDyn, x64reg
| pusha
| xor eax, eax
| mov vmArg2, x64reg
| mov64 vmRegTmp2, (size_t) &printf
| mov64 vmArg1, (size_t) "[0x%zx]"
| call vmRegTmp2
| popa
|.endmacro

|.macro vmLoadArg, x64reg, arg
||do
||{
||vm_ir_arg_t *arg_ = (arg);
||switch (arg_->type)
||{
||case VM_IR_ARG_FUNC:
||{
    |lea x64reg, [=>arg_->func->id]
    ||break;
||}
||case VM_IR_ARG_REG:
||{
    |vmLoad x64reg, arg_->reg
    ||break;
||}
||case VM_IR_ARG_NUM:
||{
    |mov x64reg, arg_->num << 1
    ||break;
||}
||}
||} while (0);
|.endmacro

|.macro vmPrintNum, index
||do
||{
    | pusha
    ||size_t op_ = index;
    ||do
    ||{
        | mov vmArg1, '0' + op_ % 10
        | call aword &putchar
        ||op_ /= 10;
    ||} while (op_ != 0);
    | popa
||} while (0);
|.endmacro

|.macro vmPrintStr, str
||do
||{
    | pusha
    ||const char *str_ = str;
    ||while (*str_)
    ||{
        | mov vmArg1, (size_t) *str_
        | call aword &putchar
        ||str_+=1;
    ||}
    | popa
||} while (0);
|.endmacro

static void *link_and_encode(dasm_State **d)
{
    size_t sz;
    void *buf;
    dasm_link(d, &sz);
#ifdef _WIN32
    buf = VirtualAlloc(0, sz, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
#else
    buf = mmap(0, sz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
#endif
    dasm_encode(d, buf);
#ifdef _WIN32
    {
        DWORD dwOld;
        VirtualProtect(buf, sz, PAGE_EXECUTE_READ, &dwOld);
    }
#else
    mprotect(buf, sz, PROT_READ | PROT_EXEC);
#endif
    return buf;
}

void vm_ir_be_jit(size_t nops, vm_ir_block_t *blocks)
{
    vm_gc_t gc;
    vm_gc_init(&gc);
    dasm_State *d;
    dasm_State **Dst = &d;
    |.section code
    dasm_init(Dst, DASM_MAXSECTION);
    |.globals lbl_
    void *labels[lbl__MAX];
    dasm_setupglobal(&d, labels, lbl__MAX);
    |.actionlist bf_actions
    dasm_setup(Dst, bf_actions);
    dasm_growpc(Dst, nops);
    |.code
    |->entry:
    | jmp =>0
    for (size_t index = 0; index < nops; index++)
    {
        vm_ir_block_t *block = &blocks[index];
        if (block->id != index)
        {
            continue;
        }
        |=>index:
        for (size_t ninstr = 0; ninstr < block->len; ninstr++)
        {
            vm_ir_instr_t *instr = block->instrs[ninstr];
            switch (instr->op)
            {
            case VM_IR_IOP_NOP:
            {
                break;
            }
            case VM_IR_IOP_MOVE:
            {
                | vmLoadArg vmRegTmp1, instr->args[0]
                | vmStore instr->out->reg, vmRegTmp1
                break;
            }
            case VM_IR_IOP_ADD:
            {
                | vmLoadArg vmRegTmp1, instr->args[0]
                | vmLoadArg vmRegTmp2, instr->args[1]
                | add vmRegTmp1, vmRegTmp2
                | vmStore instr->out->reg, vmRegTmp1
                break;
            }
            case VM_IR_IOP_SUB:
            {
                | vmLoadArg vmRegTmp1, instr->args[0]
                | vmLoadArg vmRegTmp2, instr->args[1]
                | sub vmRegTmp1, vmRegTmp2
                | vmStore instr->out->reg, vmRegTmp1
                break;
            }
            case VM_IR_IOP_MUL:
            {
                | vmLoadArg rax, instr->args[0]
                | vmLoadArg rdx, instr->args[1]
                | mul rdx
                | shr rax, 1
                | vmStore instr->out->reg, rax
                break;
            }
            case VM_IR_IOP_DIV:
            {
                | xor edx, edx
                | vmLoadArg rax, instr->args[0]
                | vmLoadArg rcx, instr->args[1]
                | div rcx
                | shl rax, 1
                | vmStore instr->out->reg, rax
                break;
            }
            case VM_IR_IOP_MOD:
            {
                | xor edx, edx
                | vmLoadArg rax, instr->args[0]
                | vmLoadArg rcx, instr->args[1]
                | div rcx
                | vmStore instr->out->reg, rdx
                break;
            }
            case VM_IR_IOP_CALL:
            {
                size_t nregs = block->nregs+1;
                for (size_t arg = 1; instr->args[arg]; arg++)
                {
                    vm_ir_arg_t *val = instr->args[arg];
                    | vmLoadArg vmRegTmp1, val
                    | vmStore arg + nregs, vmRegTmp1
                }
                if (instr->args[0]->type == VM_IR_ARG_REG)
                {
                    | vmLoadArg vmRegTmp2, instr->args[0]
                }
                | add vmRegStack, nregs * sizeof(size_t)
                | lea vmRegTmp1, [>1]
                | push vmRegTmp1
                if (instr->args[0]->type == VM_IR_ARG_REG)
                {
                    | jmp vmRegTmp2
                }
                else if (instr->args[0]->type == VM_IR_ARG_FUNC)
                {
                    | jmp =>instr->args[0]->func->id
                }
                else
                {
                    __builtin_trap();
                }
                |1:
                | sub vmRegStack, nregs * sizeof(size_t)
                if (instr->out != NULL && instr->out->type == VM_IR_ARG_REG)
                {
                    | vmStore instr->out->reg, vmRegTmp1
                }
                break;
            }
            case VM_IR_IOP_ARR:
            {
                | pusha
                | vmLoadArg vmArg2, instr->args[0]
                | mov64 vmArg1, (size_t) &gc
                | mov64 vmRegTmp1, (size_t) &vm_ir_be_jit_alloc
                | call vmRegTmp1
                | popa
                | vmStore instr->out->reg, rax
                break;
            }
            case VM_IR_IOP_GET:
            {
                | pusha
                | vmLoadArg vmArg3, instr->args[1]
                | vmLoadArg vmArg2, instr->args[0]
                | mov64 vmArg1, (size_t) &gc
                | mov64 vmRegTmp1, (size_t) &vm_ir_be_jit_get
                | call vmRegTmp1
                | popa
                | vmStore instr->out->reg, rax
                break;
            }
            case VM_IR_IOP_SET:
            {
                | pusha 
                | vmLoadArg vmArg4, instr->args[2]
                | vmLoadArg vmArg3, instr->args[1]
                | vmLoadArg vmArg2, instr->args[0]
                | mov64 vmArg1, (size_t) &gc
                | mov64 vmRegTmp1, (size_t) &vm_ir_be_jit_set
                | call vmRegTmp1
                | popa
                break;
            }
            case VM_IR_IOP_LEN:
            {
                | pusha
                | vmLoadArg vmArg2, instr->args[0]
                | mov64 vmArg1, (size_t) &gc
                | mov64 vmRegTmp1, (size_t) &vm_ir_be_jit_len
                | call vmRegTmp1
                | popa
                | vmStore instr->out->reg, rax
                break;
            }
            case VM_IR_IOP_TYPE:
            {
                |vmPrintStr "error: type\n"
                break;
            }
            case VM_IR_IOP_OUT:
            {
                | pusha
                | vmLoadArg vmArg1, instr->args[0]
                | shr vmArg1, 1
                | call &putchar
                | popa
                break;
            }
            }
        }
        switch (block->branch->op)
        {
        case VM_IR_BOP_JUMP:
        {
            | jmp =>block->branch->targets[0]->id;
            break;
        }
        case VM_IR_BOP_BOOL:
        {
            | vmLoadArg vmRegTmp1, block->branch->args[0]
            | sar vmRegTmp1, 1
            | test vmRegTmp1, vmRegTmp1
            | jz =>block->branch->targets[0]->id
            | jmp =>block->branch->targets[1]->id
            break;
        }
        case VM_IR_BOP_LESS:
        {
            | vmLoadArg vmRegTmp1, block->branch->args[0]
            | vmLoadArg vmRegTmp2, block->branch->args[1]
            | cmp vmRegTmp1, vmRegTmp2
            | jl =>block->branch->targets[1]->id
            | jmp =>block->branch->targets[0]->id
            break;
        }
        case VM_IR_BOP_EQUAL:
        {
            | vmLoadArg vmRegTmp1, block->branch->args[0]
            | vmLoadArg vmRegTmp2, block->branch->args[1]
            | cmp vmRegTmp1, vmRegTmp2
            | je =>block->branch->targets[1]->id
            | jmp =>block->branch->targets[0]->id
            break;
        }
        case VM_IR_BOP_RET:
        {
            | pop vmRegTmp2
            | vmLoadArg vmRegTmp1, block->branch->args[0]
            | jmp vmRegTmp2
            break;
        }
        case VM_IR_BOP_EXIT:
        {
            | xor eax, eax
            | ret
            break;
        }
        }
    }
    link_and_encode(&d);
    dasm_free(&d);
    size_t (*fn)(size_t *) = labels[lbl_entry];
    size_t *mem = malloc(sizeof(size_t) * (1<<16));
    size_t ret = fn(mem);
    free(mem);
}
